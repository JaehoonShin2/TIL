![](https://velog.velcdn.com/images/aristia/post/3cdaad08-a52b-4d1e-b0c9-43b911cac7c6/image.png)


## 머신러닝

AI : artificial inteligence의 약자로, 사람의 사고능력을 구현한 소프트웨어(시스템)

AI 는 크게 두 가지 부류로 나뉘어 진다.

- 1. String AI(강인공지능) : 마치 아이언맨의 자비스 와 같은.. 사람과 완전히 구별이 불가능한 AI. 즉 현재 AI 연구의 최종적인 목표이자 지향점.


- 2. Weak AI(약인공지능) : 특정 목적, 분야에 대해서는 사람과 유사한 능력 혹은 그 이상의 능력을 발휘할 수 있는 AI. 바둑의 알파고, 체스의 인공지능, chat gpt, 자율주행 등등 현재 상용화되고 있는 모든 AI 는 모든 Weak AI 에 해당한다.

사람이 생화학적으로 사고를 하는 과정과,
컴퓨터가 전자기적으로 사고를 하는 과정에서
소요되는 시간적 차이는 100만 배 정도 차이가 난다고 한다.


`사람`의 사고는 과거로부터 반복적으로 학습된 기억을 바탕으로 사고가 이루어진다.

Weak AI 는 마치 사람과 같이 `Data` 를 기반으로 해서 `학습`을 시켜서 아직 일어나지 않는 일들을 `예측` 할 수 있도록 만드는 AI 라고 할 수 있다.

지끔까지 하고 있던 일반적인 프로그램의 분야는 `Rule Based Program` 이었다. 다른 말로는 `Explicit Program` 이다.

즉, 

데이터를 입력하면, 사전에 정해진 로직을 통해서 데이터가 처리되고, 최종적으로 출력이 되는 형태를 의미한다.

하지만 머신러닝의 분야는 그 형태가 조금 다르다.

데이터와 해답
(사람의 이미지와 '사람', 고양이의 이미지와 '고양이'... ) 
이 같이 입력이 이루어지면, 무언가 프로그램 처리를 하고 나서 결과적으로 출력되는 것은 `규칙성` 을 출력하게 된다.
즉, 일반적인 프로그램은 이미 정해진(정한) 규칙에 따라서 해답을 출력하는 과정이라면, 머신러닝은 데이터와 해답을 받아서 어떤 규칙성이 있는지 찾아내게 된다.

그리고 이 `규칙성`은 `수식` 으로 출력이 되게 된다.
그리고 출력된 `수식` 이 바로 `모델` 이다.

이렇게 생겨난 `모델`을 가지고 나서 데이터를 넣게 되면 `예측` 을 통해 해답을 예측해서 출력하게 된다.

---


### 머신러닝 기법

그렇다면 그러한 모델을 만들기 위해선 어떤 방법을 사용해야 할까?

#### * 1. Regression -> 지도학습

`통계` 분야에 존재하던 `회귀분석` 에서 가져온 기법
이럴 기반으로 해서 Neural Network 로 넘어가고 Deep Learning 으로 가게 된다.

2~5번까지의 기법은 이미 이론이 정형화되어 있고, 완성된 API, 라이브러리가 구현되어 존재한다. 따라서 각각의 기법의 개념이 어떤건지, 어느 케이스에 필요한 지만 배우고 사용할 수 있으면 된다.

#### 2. SVM(support vector machine) -> 지도학습

#### 3. Decision Tree, Random Forest -> 지도학습

#### 4. KNN -> 지도학습

#### 5. Navie Bayes -> 지도학습

#### * 6. (Artificial) Neural Network(ANN) => Deep Learning -> 지도학습

사람의 뇌를 본따서 만드는, 뉴런의 동작 방식을 모방해서 만들어보는 기법이 하나 존재하는데 인공신경망 기법

이 기법이 발전되면서 등장한 것이 `Deep Learning`

즉, 딥러닝은 머신러닝 기법의 한 종류 중 하나로 존재한다. 

다른 5가지의 기법과 딥러닝 기법에는 몇 가지 차이점이 존재한다.
그 중에서 가장 큰 차이점은 데이터 형태에 있다. 

일반적인 `정형데이터`(DB에 담을 수 있는 데이터... 이름,나이,생일 등) 을 사용할 때에는 일반 머신러닝 기법이 효율적이다.

반면 `비정형데이터`(이미지, 자연어, 음성, 대용량의 텍스트)을  사용할 경우 일반 머신러닝 기법으로는 학습이 잘 되지 않는다. 그 때 `딥러닝` 기법을 사용하게 된다.

AI 를 만들 때에는 정확한 결과값도 중요하지만, 예상되는 응답시간 역시 매우매우 중요하다. 특히 실시간적으로 결과를 요구하는 예측(자율주행...) 에 있어서는 응답시간이 매우 중요하다.

#### 7. K-Means, DBSCAN -> 비지도학습

#### 8. Reinforcement Learing -> 강화학습


이러한 여러 기법 중에서 어떤 기법을 선택하느냐는 내가 가진 데이터의 형태가 어느 것이냐에 따라서 설정을 할 수 있게 된다.

---

### Machine Learing Type

#### 지도학습(supervised Learing)

[ Data | label ] 형식으로 데이터를 프로그램에 전달해서 규칙성을 찾는 타입

지도학습인지 아닌지를 구분하는 것은 데이터의 형식을 보고 판단이 가능하다.

#### 비지도학습(Unsupervised Learning)

[ Data ] 형식으로 데이터를 프로그램에 전달해서 `Clustering Model` 을 출력하는 타입

#### 준지도학습(Semiseupervised Learning)

[ Data | label ]

[ Data | ]

와 같이 지도학습과 비지도학습 모두를 사용하는 타입

#### 강화학습

마치 바둑의 알파고와 같이, 현재보다 더 나은 상태를 만들어가는 타입

주로 금융권(주식, 코인, 증권...) 들에서 미래 예측을 할 때 사용하게 된다.

일반적으로 학습의 순서로는 지도학습 -> 비지도학습 -> 강화학습 순으로 접근하게 된다.

## 지도학습(Supervised Learning)

지도학습에서 데이터는 2가지로 분류된다.

*** Data 의 구조 ***
[ 학습 데이터 | Lebel ] - 입력 -> 프로그램의 실행 - 결과 -> Model(수식)

완성된 모델을 가지고 `예측` 을 하게 된다.

단변량이란, Label 의 값이 하나만 주어지는 것을 의미한다.

Label 은 무조건 한 가지가 쓰이는 것은 아니다. 
사람의 학습 데이터에 대해 Label 을 사람, 남자, 성인.. 이런 식으로 여러 Label 이 주어질 수도 있다.
`다변량` 이라 한다.

데이터의 Label 타입으로 연속적인 숫자 데이터가 나올 수도 있고, True/False 의 이산적인 숫자(분류->합격/불합격, 가능/불가능, 성공/실패..) 데이터로 나올 수도 있다.

Label 타입으로 
- 연속적인 숫자 데이터가 나오는 타입을 `Regression` 
- 이산적인 숫자(분류) 데이터가 나오는 타입을 `Classification`

** 주의해야 할 점은 Label 타입에서의 Regression 이란 것은 모델의 결과 데이터를 지칭하고, machine learning 기법 중의 Regression 은 통계의 회귀분석 기법을 기반으로 한 기법을 의미. 문맥 상에서 어떤 것을 의미하는지 구분해야 한다.


## 1. Regression(회귀분석)


어떤 데이터에 대해 그 데이터의 영향을 주는
`조건들의 영향력`을 이용해서 
`데이터에 대한 조건부 평균` 을 구하는 기법

===>>>


어떤 데이터에 대해 그 데이터의 영향을 주는
`조건들의 영향력`을 이용해서 
`데이터들에 대해서 그 데이터를 가장 잘 표현하는 함수` 을 구하는 기법

표로 만들면 사용이 너무 어려워지기 때문에, 이를 수식으로 바꾸게 된다.

예를 들어 아파트의 가격을 알아보는 수식을 작성해보자면,

![](https://velog.velcdn.com/images/aristia/post/13b6e4d4-3b7e-4d12-95ed-d689c716b786/image.png)

이렇게 만들어진 수식의 결과 정확도가 좋다면, 앞으로는 복잡한 계산이 필요없이 해당 수식에다가 필요한 데이터만 넣게 되면 향후에도 예측이 가능해진다는 것이다.

회귀분석이라는 것은 결국 이러한 수식을 만들어내는 것을 의미한다.

결국 최종적으로 `Regression(회귀분석)` 은 보다 정확한 `평균`을 구하는 수식을 찾는 것을 의미한다.

평균은 `대표값`으로 가장 많이 이용하는 값이다. 대표값이란 여러 개의 데이터 중에서 어떤 값이 이 전체 데이터를 대표할 수 있는가를 의미한다. `대표값`으로 사용할 수 있는 수를 찾을 때에는 몇몇 기법을 사용한다. `최소값`, `최대값`, `***평균`, `중간값`, `최빈값` ...

그 중에서 평균이 데이터를 가장 잘 표현하는 값, 이라고 대다수가 생각하기 때문에 주로 대표값으로 이용이 되곤 한다.

### Regression Model

#### 독립변수(Feature) 와 종속변수(target)

독립변수는 독립적으로 존재하는 변수.

독립변수의 데이터를 가지고 2차 가공된 변수. 즉 독립변수가 바뀌게 될 경우 종속변수 역시 값이 바뀌게 된다.

![](https://velog.velcdn.com/images/aristia/post/a6f8d06e-de8c-4ace-a71b-7820a9d5aea0/image.png)

연수기간과 공부시간에 따라서 성적이 변화한다.

지도학습에서 보자면, 독립변수는 x-data 를 의미하고, 종속변수는 label 을 의미하게 된다.

![](https://velog.velcdn.com/images/aristia/post/344e714f-d81f-4be3-8f3d-4a3f3f2a6c22/image.png)

기본적으로 한 개의 독립변수와 한 개의 종속변수를 가지고 수식을 만들게 되면 1차원 직선의 수식이 나오게 된다.

그리고 1차원 직선 수식을 `classical linear Regression` 이라고 부른다.

![](https://velog.velcdn.com/images/aristia/post/da7cba90-d217-4602-bdcc-a494f95f44cd/image.jpeg)


그런데 독립변수 혹은 종속변수의 갯수가 1개씩 늘어갈수록 2차원, 3차원으로 늘어나게 되고 수식 역시 면, 공간 등으로 바뀌게 된다.

![](https://velog.velcdn.com/images/aristia/post/85179c9b-5906-433a-91b5-d1303d985e48/image.jpeg)

만약 데이터가 평균을 사용하기 힘든 데이터라면 회귀모델 사용을 고려해야 한다.
(데이터 상에서 큰 사이즈의 아웃라이너가 존재한다면)

따라서, 데이터의 분포도를 알아야만 한다.

예시로 성인의 키 데이터를 보게 되면 정규분포의 형태를 띄게 된다.
반대로 연봉 데이터의 경우에는 분포도가 편향되게 나오게 된다. 만약 편향된 데이터를 사용해야만 할 경우, 이 편향을 보간해주는 과정이 필요해진다.


#### 왜 Regression(회귀) 일까

1800년 대 찰스 다윈의 책인 "종의 기원"
찰스 다윈의 친인척 중 프란시스 라는 인물이 우성인자를 이용헤 더 나은 인류가 되자라는 의미로 우생학을 시작했다.
그 때 큰 키를 우성, 작은 키를 열성으로 생각하고 데이터를 모으기 시작했다.

데이터를 모으다보니, 큰 키의 아버지를 가진 자식 중에도 작은 키의 아이가 태어나기도 하고 작은 키의 아버지를 가진 자식 중에도 큰 키의 아이가 태어나기도 한다.
이를 결국 모아서 평균을 내보니... Regression towoard Mean...  => `Regression`

---

### matplotlib.pyplot

#### plt.scatter('독립변수', '종속변수')

그래프로 데이터의 분포를 보여주는 함수

![](https://velog.velcdn.com/images/aristia/post/ea371a89-1466-45ba-b129-8213467801c1/image.png)

#### plot(x, y)

직선을 그려주는 함수

![](https://velog.velcdn.com/images/aristia/post/e715df00-6a64-4dee-96d5-9bee3b222302/image.png)

직선을 계속해서 고쳐가면서 어떤 직선이 우리의 값을 가장 잘 대표하는지를 찾아내는 과정. 정확히는 y 인자로 들어가는 가중치와 보정치의 값이 어떤 것이 가장 알맞은 값인지를 찾아가는 과정.

y = ax + b
=> 
y = wx + b

w = weight
b = bias

이 그래프가 점들을 잘 대표하고 있는지 판단해야만 한다.
잘 표현하고 있지 못하다면, 더 나은 w와 b를 찾아야 한다.

이 판단의 기준이 뭘까?? => 오차(ERROR)
오차는 실제값 - 추정값 ( t - y )
오차는 `평균제곱오차(MSE)` `Min Squared Error` 를 가지고 하게 된다.

내가 만든 모델이 잘 만들어졌는지를 판단하는 기준이 평균제곱오차가 된다.

Loss 함수 : 내 모델이 좋은지 나쁜지를 판단하는 함수. 즉, 우리는 Loss 함수로써 MSE 를 사용하게 되는 것이다!

$\dfrac{\sum ^{n}_{i=1}\left( t_{i}-y_{i}\right) ^{2}}{n}$

![](https://velog.velcdn.com/images/aristia/post/1c9ea9b9-3144-4950-bf83-8070e4b41686/image.png)

![](https://velog.velcdn.com/images/aristia/post/caf99e25-477d-41c1-a15d-6775179237c1/image.jpeg)

![](https://velog.velcdn.com/images/aristia/post/0d6c3b6a-bb55-48d6-97db-742c9ce03217/image.jpeg)

정답(t) - 예측값(y)을 비교해서 괜찮다면 종료.
만약 그 간격이 너무 커서 ng 라면 w와 b를 갱신한다. 
w' = w - a(미분값)
b' = b - a(미분값)

새로운 w와 b 값을 가지고 다시 예측값을 만들고, 정답과 예측값을 비교한다.
이 과정을 계속해서 반복하면서 궁극적으로 이 모델이 만들어질 때 까지 반복한다.

이를 반복학습을 통해 만든다.


원래라면, y를 찾기 위해서 y=wx+b 의 수식에 반복적으로 대입을 해야 했는데, 이것을 행렬곱을 이용해 빠르게 해결할 수 있도록 한다.

x 의 데이터가 4x1 의 행렬이라면, w 데이터를 1x1 의 행렬로 만들어서 바로 4x1 의 행렬 데이터를 만든다.

![](https://velog.velcdn.com/images/aristia/post/bf8a8770-f835-4d03-9a9c-e91708a86b47/image.jpeg)


#### 머신러닝의 라이브러리

#### 1. google 의 Tensorflow + keras



#### 2. meta 의 pytouch


### from tensorflow.keras.models import Sequential

![](https://velog.velcdn.com/images/aristia/post/fa044d5c-38f2-4eac-9620-348da933e34a/image.png)

왜 Sequential 이냐 하면, `Model` 의 박스에서 왼쪽에서 오른쪽으로 순차적으로 흐르면서 프로세스가 진행되기 때문이다.

Model 내부에 있는 layer 에는 두 가지가 있다.

![](https://velog.velcdn.com/images/aristia/post/2056a2b6-e6ad-4a42-9c70-7b6628b47067/image.png)

![](https://velog.velcdn.com/images/aristia/post/648c0fbd-22b4-4a5e-8ad8-684792ec69aa/image.png)


